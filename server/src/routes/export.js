import { Router } from 'express'
import PDFDocument from 'pdfkit'
import { composePlan } from '../services/plan.js'

const router = Router()

function streamPdf(res, filename, build) {
  res.setHeader('Content-Type', 'application/pdf')
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`)
  const doc = new PDFDocument({ size: 'A4', margin: 50 })
  doc.info = { Title: filename }
  doc.pipe(res)
  build(doc)
  doc.end()
}

function header(doc, title) {
  doc.fontSize(20).text(title, { align: 'center' })
  doc.moveDown(0.5)
  doc.moveTo(50, doc.y).lineTo(545, doc.y).strokeColor('#cccccc').stroke()
  doc.moveDown(1)
}

function footer(doc) {
  const bottom = 780
  doc.fontSize(8).fillColor('#666').text('Generated by Couples Therapy & Insights Platform', 50, bottom, { align: 'left' })
  doc.fillColor('black')
}

// GET /export/report/:coupleId
router.get('/report/:coupleId', async (req, res) => {
  try {
    const supabase = req.supabase
    const coupleId = req.params.coupleId
    const { data: report, error } = await supabase.rpc('get_couple_report', { p_couple_id: coupleId })
    if (error) return res.status(400).json({ error: error.message })
    if (!report) return res.status(404).json({ error: 'Report not available' })

    streamPdf(res, `couple-report-${coupleId}.pdf`, (doc) => {
      header(doc, 'Couple Report')
      doc.fontSize(10)
      doc.text(`Couple: ${coupleId}`)
      doc.text(`Generated: ${new Date().toLocaleString()}`)
      doc.moveDown()

      // Summary
      if (report.risk_index !== undefined && report.risk_index !== null) {
        doc.fontSize(12).text(`Risk Index: ${report.risk_index}`, { continued: false })
        doc.moveDown(0.5)
      }

      // Domains table (simple text rows)
      const domains = Array.isArray(report.domains) ? report.domains : []
      if (domains.length) {
        doc.fontSize(14).text('Domain Scores', { underline: true })
        doc.moveDown(0.5)
        doc.fontSize(10)
        doc.text('Domain'.padEnd(16) + 'Score A'.padEnd(10) + 'Score B'.padEnd(10) + 'Gap')
        doc.moveTo(50, doc.y).lineTo(545, doc.y).strokeColor('#dddddd').stroke()
        doc.moveDown(0.25)
        domains.forEach(d => {
          const line = `${String(d.domain).padEnd(16)}${String(d.score_a ?? '').padEnd(10)}${String(d.score_b ?? '').padEnd(10)}${String(d.gap ?? '')}`
          doc.text(line)
        })
      }

      doc.addPage()
      header(doc, 'Notes')
      doc.fontSize(10).fillColor('#666').text('Raw text responses are not included in this PDF. Coach-facing views are consent-aware.')
      doc.fillColor('black')
      footer(doc)
    })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Failed to export report' })
  }
})

// GET /export/plan/:coupleId
router.get('/plan/:coupleId', async (req, res) => {
  try {
    const supabase = req.supabase
    const coupleId = req.params.coupleId

    const { data: active, error: actErr } = await supabase
      .from('active_assessment').select('*').maybeSingle()
    if (actErr || !active) return res.status(400).json({ error: 'No active assessment' })

    // Force report availability to ensure both submissions completed
    const { error: repErr } = await supabase.rpc('get_couple_report', { p_couple_id: coupleId })
    if (repErr) return res.status(400).json({ error: repErr.message })

    const plan = await composePlan(supabase, coupleId, active.id)

    streamPdf(res, `couple-plan-${coupleId}.pdf`, (doc) => {
      header(doc, 'Personalized Plan â€” 2 Weeks')
      doc.fontSize(10)
      doc.text(`Couple: ${coupleId}`)
      doc.text(`Generated: ${new Date().toLocaleString()}`)
      if (plan?.meta?.risk_index !== undefined && plan?.meta?.risk_index !== null) {
        doc.text(`Risk Index: ${plan.meta.risk_index}`)
      }
      doc.moveDown()

      // Issues
      if (Array.isArray(plan?.issues) && plan.issues.length) {
        doc.fontSize(14).text('Top Issues', { underline: true })
        doc.moveDown(0.5)
        doc.fontSize(11)
        plan.issues.forEach((i, idx) => {
          doc.text(`${idx + 1}. [${i.domain}] gap ${i.gap}, avg score ${i.avgScore}`)
        })
        doc.moveDown(0.5)
      }

      // Weeks
      const weeks = plan?.plan?.weeks || []
      weeks.forEach((w, wi) => {
        doc.addPage()
        doc.fontSize(16).text(w.title)
        doc.moveDown(0.5)
        if (Array.isArray(w.items)) {
          w.items.forEach((it, ii) => {
            doc.fontSize(12).text(`${ii + 1}. [${it.domain}] ${it.title}`, { underline: false })
            if (it.body) {
              doc.fontSize(10).text(it.body, { align: 'left' })
            }
            const actions = Array.isArray(it.actions) ? it.actions : []
            if (actions.length) {
              doc.moveDown(0.2)
              actions.forEach((a, ai) => {
                doc.fontSize(10).text(`- ${a}`)
              })
            }
            doc.moveDown(0.5)
          })
        }
      })

      // Coach checklist
      if (Array.isArray(plan?.coach_checklist) && plan.coach_checklist.length) {
        doc.addPage()
        doc.fontSize(14).text('Coach Checklist', { underline: true })
        doc.moveDown(0.5)
        plan.coach_checklist.forEach((c, i) => doc.fontSize(10).text(`- ${c}`))
      }

      footer(doc)
    })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Failed to export plan' })
  }
})

export default router

